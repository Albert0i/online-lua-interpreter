#!lua name=findlib

--[[
        ███████╗  ██╗  ███╗░░██╗  ██████╗░
        ██╔════╝  ██║  ████╗░██║  ██╔══██╗
        █████╗░░  ██║  ██╔██╗██║  ██║░░██║
        ██╔══╝░░  ██║  ██║╚████║  ██║░░██║
        ██║░░░░░  ██║  ██║░╚███║  ██████╔╝
        ╚═╝░░░░░  ╚═╝  ╚═╝░░╚══╝  ╚═════╝░
        Note: Generated by AI, please skip to line 212.
]]
--[[
  Return Redis hashes matching a pattern and a simple condition, 
  Parameters:
      KEYS[1] - Key pattern to scan for, "users:*";
      KEYS[2] - Expression to evaluate for, "role='admin' and status='inactive'";
      KEYS[3] - Number of documents to skip, 0 if unspecified; 
      KEYS[4] - Maximum number of documents to return, 10 if unspecified; 
      ARGV[]  - Fields to return, "id, name, status" for example, 
                Return all fields if unspecified.
]]
local function find(KEYS, ARGV)
    local precedence = {
        ["not"] = { prec = 3, assoc = "right" },
        ["="]   = { prec = 2, assoc = "left" },
        ["<>"]  = { prec = 2, assoc = "left" },
        [">="]  = { prec = 2, assoc = "left" },
        ["<="]  = { prec = 2, assoc = "left" },
        [">"]  = { prec = 2, assoc = "left" },
        ["<"]  = { prec = 2, assoc = "left" },
        ["and"] = { prec = 1, assoc = "left" },
        ["or"]  = { prec = 1, assoc = "left" },
        ["+"]   = {prec = 5, assoc = "left"},
        ["-"]   = {prec = 5, assoc = "left"},
        ["*"]   = {prec = 6, assoc = "left"},
        ["/"]   = {prec = 6, assoc = "left"},    
    }
      
    -- Tokenizer: splits expression into tokens
    local function tokenize(expr)
        local tokens = {}
        local i = 1
        local len = #expr
    
        local function peek(n)
            return expr:sub(i, i + (n or 0))
        end
    
        local function advance(n)
            i = i + (n or 1)
        end
    
        local function skip_whitespace()
        while i <= len and expr:sub(i, i):match("%s") do
            advance()
        end
        end
        
        while i <= len do
            skip_whitespace()
            local c = peek()
    
            -- Parentheses
            if c == "(" or c == ")" then
                table.insert(tokens, c)
                advance()
    
            -- Multi-char comparison operators
            elseif peek(1) == ">=" or peek(1) == "<=" or peek(1) == "<>" then
                table.insert(tokens, peek(1))
                advance(2)
    
            -- Single-char comparison or arithmetic operators
            elseif c == "=" or c == "<" or c == ">" or c == "+" or c == "-" or c == "*" or c == "/" then
                table.insert(tokens, c)
                advance()
    
            -- Quoted strings
            elseif c == "'" or c == '"' then
                local quote = c
                local j = i + 1
                while j <= len and expr:sub(j, j) ~= quote do
                    j = j + 1
                end
                local str = expr:sub(i, j)
                table.insert(tokens, str)
                i = j + 1
            
            -- Identifiers and keywords
            elseif c:match("[%w_]") then
                local j = i
                while j <= len and expr:sub(j, j):match("[%w_]") do
                    j = j + 1
                end
                local word = expr:sub(i, j - 1)
                table.insert(tokens, word)
                i = j
    
            else
                -- Unknown character, skip
                advance()
            end
        end
    
        return tokens
    end
      
    -- Infix to RPN using Shunting Yard algorithm
    local function infix_to_rpn(expr_str)
        local output, stack = {}, {}
        local tokens = tokenize(expr_str)
    
        for _, token in ipairs(tokens) do
            if token == "(" then
                table.insert(stack, token)
            elseif token == ")" then
            while #stack > 0 and stack[#stack] ~= "(" do
                table.insert(output, table.remove(stack))
            end
            table.remove(stack) -- remove "("
            elseif precedence[token] then
            while #stack > 0 do
                local top = stack[#stack]
                local p1 = precedence[token]
                local p2 = precedence[top]
                if p2 and ((p1.assoc == "left" and p1.prec <= p2.prec) or
                            (p1.assoc == "right" and p1.prec < p2.prec)) then
                    table.insert(output, table.remove(stack))
                else
                    break
                end
            end
                table.insert(stack, token)
            else
                table.insert(output, token)
            end
        end
    
        while #stack > 0 do
            table.insert(output, table.remove(stack))
        end
        return output
    end
    
    -- Utility: strip quotes from string
    local function stripQuotes(s)
        return s:match("^'(.*)'$") or s:match('^"(.*)"$') or s
    end
      
    -- Utility: convert to boolean
    local function toBoolean(v)
        if type(v) == "string" then
            return v ~= "" and v ~= "false"
        end
        return not not v
    end
      
    -- RPN evaluator
    local function evaluate_rpn(record, expr_table)
        local stack = {}
    
        for _, token in ipairs(expr_table) do
            if token == "=" then
                local b = stripQuotes(table.remove(stack))
                local a = table.remove(stack)
                table.insert(stack, tostring(record['map'][a]) == b)
    
            elseif token == "<>" then
                local b = stripQuotes(table.remove(stack))
                local a = table.remove(stack)
                table.insert(stack, tostring(record['map'][a]) ~= b)
    
            elseif token == ">=" then
                local b = tonumber(stripQuotes(table.remove(stack)))
                local a = tonumber(record['map'][table.remove(stack)])
                table.insert(stack, a >= b)
    
            elseif token == "<=" then
                local b = tonumber(stripQuotes(table.remove(stack)))
                local a = tonumber(record['map'][table.remove(stack)])
                table.insert(stack, a <= b)
    
            elseif token == ">" then
                local b = tonumber(stripQuotes(table.remove(stack)))
                local a = tonumber(record['map'][table.remove(stack)])
                table.insert(stack, a > b)
    
            elseif token == "<" then
                local b = tonumber(stripQuotes(table.remove(stack)))
                local a = tonumber(record['map'][table.remove(stack)])
                table.insert(stack, a < b)
    
            elseif token == "and" then
                local b = toBoolean(table.remove(stack))
                local a = toBoolean(table.remove(stack))
                table.insert(stack, a and b)
    
            elseif token == "or" then
                local b = toBoolean(table.remove(stack))
                local a = toBoolean(table.remove(stack))
                table.insert(stack, a or b)
    
            elseif token == "not" then
                local a = toBoolean(table.remove(stack))
                table.insert(stack, not a)
    
            elseif token == "+" then
                local b = tonumber(table.remove(stack))
                local a = tonumber(table.remove(stack))
                table.insert(stack, a + b)
    
            elseif token == "-" then
                local b = tonumber(table.remove(stack))
                local a = tonumber(table.remove(stack))
                table.insert(stack, a - b)
    
            elseif token == "*" then
                local b = tonumber(table.remove(stack))
                local a = tonumber(table.remove(stack))
                table.insert(stack, a * b)
    
            elseif token == "/" then
                local b = tonumber(table.remove(stack))
                local a = tonumber(table.remove(stack))
                table.insert(stack, a / b)
    
            else
                -- Push raw token (could be a literal or a key)
                table.insert(stack, token)
            end
        end
    
        return toBoolean(stack[1])
    end
    
    --[[
        main 
    ]]
    local keyPrefix = KEYS[1] or "*"
    local expr1 = KEYS[2] or "1"
    local rpn = infix_to_rpn(expr1)
    local offset = tonumber(KEYS[3]) or 0
    local limit = tonumber(KEYS[4]) or 10
    
    local cursor = "0"  -- the cursor.
    local matched = {}  -- result to be returned 
    local index = 1     -- index to place retrieved value
      
    repeat
        redis.setresp(2) -- RESP2 
        local scan = redis.call("SCAN", cursor, "MATCH", keyPrefix, "COUNT", 100, 'TYPE', 'HASH')
        -- "scan" returns [ cursor, keys ]
        cursor = scan[1]
        local keys = scan[2]
    
        for _, key in ipairs(keys) do
            -- Get all values to evaluate 
            redis.setresp(3) -- RESP3
            local row = redis.call("HGETALL", key)
            -- If found and evaluate to true
            if (row) and (evaluate_rpn(row, rpn)) then 
                -- Skip offset 
                if offset > 0 then 
                    offset = offset - 1
                else 
                    -- Take limit 
                    if limit > 0 then 
                        -- If no field names specified to return 
                        if (ARGV[1] or "*") == "*" then
                            table.insert(matched, row) 
                        else
                            --table.insert(matched, redis.call("HMGET", key, unpack(ARGV))) 
                            local slimrow = {}
                            for _, v in ipairs(ARGV) do
                                slimrow[v] = row['map'][v]
                            end
                            table.insert(matched, { map=slimrow}) 
                        end
    
                        -- Increase the index 
                        index = index + 1
                        -- Decrease the limit
                        limit = limit - 1
                    else 
                        -- Readhed limit before scan completed
                        return { map=matched }
                    end 
                end         
            end
        end 
    until (cursor == "0") -- Loop until no more keys found
end

--
-- Register Redis Functions 
-- 
redis.register_function{
  function_name='find',
  callback=find,
  flags={ 'no-writes' }, 
  description = 'Return Redis hashes matching a pattern and a simple condition'
}

--
-- FCALL_RO FIND 2 "users:*" "role='admin' and status='inactive'"
-- FCALL_RO FIND 4 "users:*" "role='admin' and status='inactive'" 0 3
-- FCALL_RO FIND 4 "users:*" "role='admin' and status='inactive'" 0 5 id  name createdAt
--